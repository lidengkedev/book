(self.webpackChunkbook=self.webpackChunkbook||[]).push([[729],{9274:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-5404b4b2",path:"/guide/linux/",title:"Linux",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"命令编辑及光标移动",slug:"命令编辑及光标移动",children:[]},{level:2,title:"历史命令快速执行",slug:"历史命令快速执行",children:[]},{level:2,title:"部分历史命令查看",slug:"部分历史命令查看",children:[]},{level:2,title:"实时查看日志",slug:"实时查看日志",children:[]},{level:2,title:"磁盘或者内存情况查看",slug:"磁盘或者内存情况查看",children:[]},{level:2,title:"根据名字查找进程",slug:"根据名字查找进程",children:[]},{level:2,title:"根据名称杀死进程",slug:"根据名称杀死进程",children:[]},{level:2,title:"查看进程运行时间",slug:"查看进程运行时间",children:[]},{level:2,title:"快速目录切换",slug:"快速目录切换",children:[]},{level:2,title:"多条命令执行",slug:"多条命令执行",children:[]},{level:2,title:"查看压缩日志文件",slug:"查看压缩日志文件",children:[]},{level:2,title:"删除乱码文件",slug:"删除乱码文件",children:[]},{level:2,title:"清空文件内容",slug:"清空文件内容",children:[]},{level:2,title:"将日志同时记录文件并打印到控制台",slug:"将日志同时记录文件并打印到控制台",children:[]},{level:2,title:"终止并回复进程执行",slug:"终止并回复进程执行",children:[]},{level:2,title:"计算程序运行时间",slug:"计算程序运行时间",children:[]},{level:2,title:"查看内存占用前10的进程",slug:"查看内存占用前10的进程",children:[]},{level:2,title:"快速查找你需要的命令",slug:"快速查找你需要的命令",children:[]},{level:2,title:"命令行下复制粘贴",slug:"命令行下复制粘贴",children:[]},{level:2,title:"搜索包含某个字符串的文件",slug:"搜索包含某个字符串的文件",children:[]},{level:2,title:"屏幕冻结",slug:"屏幕冻结",children:[]},{level:2,title:"无编辑器情况下编辑文本文件",slug:"无编辑器情况下编辑文本文件",children:[]},{level:2,title:"查看 elf 文件",slug:"查看-elf-文件",children:[]}],filePathRelative:"guide/linux/README.md",git:{updatedTime:null,contributors:[]}}},5389:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>l});const e=(0,a(6252).uE)('<h1 id="linux" tabindex="-1"><a class="header-anchor" href="#linux" aria-hidden="true">#</a> Linux</h1><h2 id="命令编辑及光标移动" tabindex="-1"><a class="header-anchor" href="#命令编辑及光标移动" aria-hidden="true">#</a> 命令编辑及光标移动</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ctrl + u    : 删除从开头到光标处的命令文本\nctrl + k    : 删除从光标到结尾处的命令文本\nctrl + a    : 光标移动到命令开头\nctrl + e    : 光标移动到命令结尾\nalt + f     : 光标向前移动一个单词\nalt + b     : 光标向前移动一个单词\natrl + w    : 删除一个词（以空格隔开的字符串）\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="历史命令快速执行" tabindex="-1"><a class="header-anchor" href="#历史命令快速执行" aria-hidden="true">#</a> 历史命令快速执行</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ctrl + r : 搜索执行过得命令\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="部分历史命令查看" tabindex="-1"><a class="header-anchor" href="#部分历史命令查看" aria-hidden="true">#</a> 部分历史命令查看</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># history 会显示大量的历史命令，而fs -l只会显示部分</span>\n\n$ fs -l\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="实时查看日志" tabindex="-1"><a class="header-anchor" href="#实时查看日志" aria-hidden="true">#</a> 实时查看日志</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># tail -f 加文件名，可以实时显示日志文件内容</span>\n<span class="token comment"># 使用 less 命令查看文件内容，并且使用 shift + f 键，也可以达到类似的效果</span>\n\n$ <span class="token function">tail</span> -f filename.log\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="磁盘或者内存情况查看" tabindex="-1"><a class="header-anchor" href="#磁盘或者内存情况查看" aria-hidden="true">#</a> 磁盘或者内存情况查看</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 使用 df 命令可以快速查看各挂载路径磁盘占用情况</span>\n\n$ <span class="token function">df</span> -h\n/dev/sda14   <span class="token number">4</span>.6G   10M     <span class="token number">4</span>.4G    <span class="token number">1</span>%\n/dev/sda11   454M  366M      61M   <span class="token number">86</span>%\n/dev/sda15    55G   18G      35G   <span class="token number">35</span>%\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果已经知道home目录占用空间较大了，想知道home目录下各个目录占用情况：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 这里指定了路径的深度，否则的话，它会递归统计子目录占用空间大小</span>\n\n$ <span class="token function">du</span> -h --max-depth<span class="token operator">=</span><span class="token number">1</span> /home<span class="token punctuation">(</span>或者-d <span class="token number">1</span><span class="token punctuation">)</span>\n18G     /home/hyb\n16K     /home/lost+fund\n18G     /home/\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 当前内存的使用情况</span>\n<span class="token comment"># 通过free的结果，很容易看到当前总共内容多少，剩余可用内存多少</span>\n\n$ <span class="token function">free</span> -h\n            total     used\nMem:        <span class="token number">7</span>.7G      <span class="token number">3</span>.5G\nSwap:       <span class="token number">7</span>.6G        0B\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用 -h 参数：</p><p>-h 参数的作用是使得结果以人类可读的方式呈现</p><h2 id="根据名字查找进程" tabindex="-1"><a class="header-anchor" href="#根据名字查找进程" aria-hidden="true">#</a> 根据名字查找进程</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># hello 是进程名</span>\n\n$ pgrep hello\n\n<span class="token comment"># 或</span>\n\n$ pidof hello\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="根据名称杀死进程" tabindex="-1"><a class="header-anchor" href="#根据名称杀死进程" aria-hidden="true">#</a> 根据名称杀死进程</h2><p>一般我们可以使用 kill -9 pid 方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">killall</span> hello\n\n<span class="token comment"># 或</span>\n\n$ <span class="token function">pkill</span> hello\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="查看进程运行时间" tabindex="-1"><a class="header-anchor" href="#查看进程运行时间" aria-hidden="true">#</a> 查看进程运行时间</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">ps</span> -p <span class="token number">24525</span> -o lstart.etime\n                 STARTED    ELAPSED\nSat Mar <span class="token number">23</span> <span class="token number">20</span>:52:08 <span class="token number">2019</span>      02:45\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="快速目录切换" tabindex="-1"><a class="header-anchor" href="#快速目录切换" aria-hidden="true">#</a> 快速目录切换</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 回到上一个目录</span>\n\n$ <span class="token builtin class-name">cd</span> -\n\n<span class="token comment"># 回到用户家目录</span>\n\n$ <span class="token builtin class-name">cd</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="多条命令执行" tabindex="-1"><a class="header-anchor" href="#多条命令执行" aria-hidden="true">#</a> 多条命令执行</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 如果当前目录是 / 目录，并且 /temp/log目录不存在，那么就会</span>\n<span class="token comment"># bash: cd: /temp/log: No such file or directory (突然陷入沉默)</span>\n<span class="token comment"># 因为 ; 可以执行多条命令，但是不会因为前一条命令失败而导致后面的不会执行</span>\n<span class="token comment"># 因此，cd 执行失败后，仍然会继续执行 rm -rf *</span>\n<span class="token comment"># 解决方案是：cd /temp/log&amp;&amp;rm -rf *</span>\n<span class="token comment"># 这样就会确保前面一条命令执行成功，才会执行后面一条</span>\n\n$ <span class="token builtin class-name">cd</span> /temp/log/<span class="token punctuation">;</span><span class="token function">rm</span> -rf *\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="查看压缩日志文件" tabindex="-1"><a class="header-anchor" href="#查看压缩日志文件" aria-hidden="true">#</a> 查看压缩日志文件</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ zcat test.gz\n\n<span class="token comment"># 或</span>\n\n$ zless test.gz\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="删除乱码文件" tabindex="-1"><a class="header-anchor" href="#删除乱码文件" aria-hidden="true">#</a> 删除乱码文件</h2><p>无论是自已意外创建还是程序异常创建，难免会出现一些命令奇怪或者乱码文件，可以选择删除Linux中特殊名称文件的多种方式</p><p>对于特殊字符，如&lt;&gt;!*等组成的文件如何删除呢？如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">rm</span> <span class="token operator">&lt;&gt;</span><span class="token punctuation">\\</span><span class="token operator">!</span>*\n<span class="token function">rm</span> missing operand\nTry <span class="token string">&#39;rm --help&#39;</span> <span class="token keyword">for</span> <span class="token function">more</span> infomation.\n\n<span class="token comment"># 对于这种类型文件，需要用引号将文件名包含起来</span>\n\n$ <span class="token function">rm</span> <span class="token string">&quot;&lt;&gt;\\!*&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="清空文件内容" tabindex="-1"><a class="header-anchor" href="#清空文件内容" aria-hidden="true">#</a> 清空文件内容</h2><p>比如有一个大文件，你想快速删除，或者不想删除，但是想清空内容：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token operator">&gt;</span>filename\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="将日志同时记录文件并打印到控制台" tabindex="-1"><a class="header-anchor" href="#将日志同时记录文件并打印到控制台" aria-hidden="true">#</a> 将日志同时记录文件并打印到控制台</h2><p>在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使用技能记录日志文件，又能将日志输出到控制台呢？</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ ./test.sh <span class="token operator">|</span><span class="token function">tee</span> test.log\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="终止并回复进程执行" tabindex="-1"><a class="header-anchor" href="#终止并回复进程执行" aria-hidden="true">#</a> 终止并回复进程执行</h2><p>我们使用 ctrl + Z 暂停一个进程的执行，也可以使用fg恢复执行。例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> filename\n\n<span class="token comment"># 当我们发现文件过多的时候，使用 ctrl + z 暂停程序，</span>\n<span class="token comment"># 而如果又想要从刚才的地方继续执行，则只需要使用fg命令即可恢复执行。</span>\n<span class="token comment"># 或者使用bg使得进程继续在后台执行</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="计算程序运行时间" tabindex="-1"><a class="header-anchor" href="#计算程序运行时间" aria-hidden="true">#</a> 计算程序运行时间</h2><p>我们可能会用进程写一些小程序，并想知道它的运行时间，实际上我们可以很好的利用 time 命令帮我们计算，例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 它会显示系统时间，用户时间以及实际使用的总时间</span>\n\n$ <span class="token function">time</span> ./fibo <span class="token number">30</span>\nthe <span class="token number">30</span> result is <span class="token number">832040</span>\n\nreal    0m0.088s\nuser    0m0.084s\nsys     0m0.004s\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="查看内存占用前10的进程" tabindex="-1"><a class="header-anchor" href="#查看内存占用前10的进程" aria-hidden="true">#</a> 查看内存占用前10的进程</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">ps</span> -aux<span class="token operator">|</span><span class="token function">sort</span> -k4nr <span class="token operator">|</span><span class="token function">head</span> -n <span class="token number">10</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="快速查找你需要的命令" tabindex="-1"><a class="header-anchor" href="#快速查找你需要的命令" aria-hidden="true">#</a> 快速查找你需要的命令</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">man</span> -k <span class="token string">&quot;copy files&quot;</span>\n<span class="token function">cp</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>          - copy files and directories\ncpio <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        - copy files to and from archives\n\n<span class="token comment"># 使用 -k 参数，使得与 copy files 相关的帮助手册都显示出来了</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="命令行下复制粘贴" tabindex="-1"><a class="header-anchor" href="#命令行下复制粘贴" aria-hidden="true">#</a> 命令行下复制粘贴</h2><p>我们知道，在命令行下，复制不能再是 ctrl + c 了，因为它表示终止当前进程，而控制台下的复制粘贴需要使用下面的快捷键：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ctrl + insert\nshift + insert\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="搜索包含某个字符串的文件" tabindex="-1"><a class="header-anchor" href="#搜索包含某个字符串的文件" aria-hidden="true">#</a> 搜索包含某个字符串的文件</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 在当前目录下查找包含test字符串的文件</span>\n\n$ <span class="token function">grep</span> -rn <span class="token string">&quot;test&quot;</span>\ntest2.txt:1:test\n\n<span class="token comment"># 它可以找到该字符串在哪个文件的第几行</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="屏幕冻结" tabindex="-1"><a class="header-anchor" href="#屏幕冻结" aria-hidden="true">#</a> 屏幕冻结</h2><p>程序运行时，终端可能输出大量日志，你想简单查看一下，又不想记录日志文件，此时可以使用 ctrl + s 键，冻结屏幕，使得日志不再继续输出，如果想要恢复，可以使用 ctrl + q 退出冻结。</p><h2 id="无编辑器情况下编辑文本文件" tabindex="-1"><a class="header-anchor" href="#无编辑器情况下编辑文本文件" aria-hidden="true">#</a> 无编辑器情况下编辑文本文件</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&gt;</span>file.txt\nsome words\n<span class="token punctuation">(</span>ctrl + d<span class="token punctuation">)</span>\n\n<span class="token comment"># 编辑完成后， ctrl + d 即可保存</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="查看-elf-文件" tabindex="-1"><a class="header-anchor" href="#查看-elf-文件" aria-hidden="true">#</a> 查看 elf 文件</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 查看elf文件头信息</span>\n\n$ readelf -n filename\n\n<span class="token comment"># 查看库中是否包含某个接口</span>\n<span class="token comment"># 这里是从文件 filename 中查看是否包含interface接口，前提是该文件包含符号表</span>\n\n$ nm filename <span class="token operator">|</span><span class="token function">grep</span> interface\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',60),l={render:function(n,s){return e}}}}]);